---
title: Browser Interaction
description: "Instruct and control what the agent should do in the browser"
icon: mouse-pointer-2
---

## Taking Action

Use **act()** to tell the agent what to do:

Instructions provided to act can be high-level tasks:
```ts
await agent.act('log in to the app');
```

or low level actions:
```ts
await agent.act('click the submit button');
```

Think of it like you're telling a coworker to do something. Breaking it up into tiny steps is unnecessary, but you want to be specific enough to make the objective clear.

### Chaining Acts

Combine multiple **act** calls to accomplish complex sequences of interactions:
```ts
await agent.act('go to tasks page');
await agent.act('assign all pending tasks to Bob');
await agent.act('move all pending tasks to "In Progress"');
```

You can also chain multiple steps together in the same act call for convenience:
```ts
await agent.act([
    'go to tasks page',
    'assign all pending tasks to Bob',
    'move all pending tasks to "In Progress"'
]);
```

### Providing Data

You can provide arbitrary data fields that the agent will use where appropriate during its actions:
```ts
await agent.act('create a new task', {
    data: {
        title: 'important task',
        description: 'some description'
    }
});
```

### Custom Prompting

Provide custom system prompt instructions as needed:
```ts
await agent.act('create a new task', {
    prompt: 'tasks should be written in spanish'
});
```

### Controlling Execution Steps

By default, each `act()` call is limited to 100 steps to prevent infinite loops. You can adjust this limit based on task complexity:

```typescript
// Simple task with default limit
await agent.act('click the submit button');

// Complex task that needs more steps
await agent.act('fill out the entire application form', {
    maxSteps: 200
});

// Very simple task with reduced limit
await agent.act('close the modal', {
    maxSteps: 3
});
```

The agent will emit a warning event if it reaches the maximum steps without completing the task, which can help identify tasks that need adjustment or debugging.

### Memory Persistence

By default, each `act()` call starts with a fresh memory context. For tasks that build upon previous actions, you can enable memory persistence:

```typescript
// First action creates some state
await agent.act('open the settings panel', {
    reuseMemory: true  // Start persistent memory
});

// Subsequent actions remember previous context
await agent.act('navigate to the security tab', {
    reuseMemory: true  // Continues with memory from previous act()
});

await agent.act('enable two-factor authentication', {
    reuseMemory: true  // Still has context from all previous actions
});
```

This is particularly useful for:
- Multi-step workflows where context matters
- Complex interactions that reference previous actions
- Test scenarios that need to maintain state across steps

Note: Memory is only persisted within the same agent instance. Creating a new agent starts fresh.

## Navigating Directly

While the agent is capable of navigating to URLs on its own, you may sometimes want to navigate to a specific URL directly.

To do this, use `nav`:
```ts
await agent.nav('https://google.com');
```

## Agent Capabilities

### What can agent do in act?

The agent is capable of **mouse**, **keyboard**, and **browser**-specific actions, including but not limited to:
- Clicking with the mouse
- Dragging with the mouse
- Typing long blocks of content
- Pressing specific keystrokes
- Switching tabs
- Navigating to URLs

### What is the agent aware of?

The agent knows about and sees:
- The current screenshot plus some past screenshots
- History of its own actions from the same `act()`
- All currently open tabs
- Which tab is active
